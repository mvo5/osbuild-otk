import argparse
import logging
import pathlib
import sys

from .constant import PREFIX_TARGET
from .context import CommonContext
from .context import registry as context_registry
from .document import Omnifest
from .help.log import JSONSequenceHandler
from .target import CommonTarget
from .target import registry as target_registry
from .transform import process_include, resolve
from .traversal import State

log = logging.getLogger(__name__)


def root() -> int:
    return run(sys.argv[1:])


def run(argv) -> int:
    parser = parser_create()
    arguments = parser.parse_args(argv)

    # turn on logging as *soon* as possible, so it can be used early
    logging.basicConfig(
        level=logging.WARNING - (10 * arguments.verbose),
        handlers=[
            (
                JSONSequenceHandler(arguments.identifier, stream=sys.stderr)
                if arguments.json
                else logging.StreamHandler()
            ),
        ],
    )

    # some arguments need to be handled before continuing with
    # subcommands
    if arguments.identifier and not arguments.json:
        parser.print_help()
        parser.exit()

    if arguments.command == "compile":
        return compile(arguments)
    if arguments.command == "validate":
        return validate(arguments)

    raise RuntimeError("Unknown subcommand")


def _process(arguments: argparse.Namespace, dry_run: bool) -> int:
    if not dry_run:
        # pylint: disable=R1732
        dst = sys.stdout if arguments.output is None else open(arguments.output, "w", encoding="utf-8")

    if arguments.input is None:
        path = pathlib.Path(f"/proc/self/fd/{sys.stdin.fileno()}")
    else:
        path = pathlib.Path(arguments.input)

    ddw = "duplicate-definition" in getattr(arguments, "warn", [])
    ctx = CommonContext(duplicate_definitions_warning=ddw)
    state = State()
    doc = Omnifest(process_include(ctx, state, path))

    target_available = doc.targets
    target_requested = arguments.target
    if len(target_available) > 1 and not target_requested:
        log.fatal("INPUT contains multiple targets, `-t` is required")
        return 1

    # set the requested target to the default case now that we know that
    # there aren't multiple targets available and none are requested
    target_requested = list(target_available.keys())[0]

    if target_requested not in target_available:
        log.fatal("requested target %r does not exist in INPUT", target_requested)
        return 1

    # and also for the specific target
    try:
        kind, name = target_requested.split(".")
    except ValueError:
        # TODO handle earlier
        log.fatal(
            "malformed target name %r. We need a format of '<TARGET_KIND>.<TARGET_NAME>'.",
            target_requested,
        )
        return 1

    # re-resolve the specific target with the specific context and target if
    # applicable
    spec = context_registry.get(kind, CommonContext)(ctx)
    state = State(path=path)
    tree = resolve(spec, state, doc.tree[f"{PREFIX_TARGET}{kind}.{name}"])

    # and then output by writing to the output
    if not dry_run:
        dst.write(target_registry.get(kind, CommonTarget)().as_string(spec, tree))

    return 0


def compile(arguments: argparse.Namespace) -> int:  # pylint: disable=redefined-builtin
    return _process(arguments, dry_run=False)


def validate(arguments: argparse.Namespace) -> int:
    return _process(arguments, dry_run=True)


def parser_create() -> argparse.Namespace:
    # set up the main parser arguments
    parser = argparse.ArgumentParser(
        prog="otk",
        description="`otk` is the omnifest toolkit. A program to work with "
        "omnifest inputs and translate them into the native formats for image "
        "build tooling.",
    )
    parser.add_argument(
        "-j",
        "--json",
        action="store_true",
        default=False,
        help="Sets output format to JSONseq. Output on stderr will be JSONseq records with ASCII record separators.",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="Sets verbosity. Can be passed multiple times to be more verbose.",
    )
    parser.add_argument(
        "-i",
        "--identifier",
        default=None,
        help="An identifier to include in all log records generated by `otk -j`. Can only be used together with `-j`.",
    )
    parser.add_argument(
        "-w",
        "--warn",
        action='append',
        default=[],
        help="Enable warnings, can be passed multiple times.",
    )

    # get a subparser action
    subparsers = parser.add_subparsers(dest="command", required=True, metavar="command")

    parser_compile = subparsers.add_parser("compile", help="Compile an omnifest.")
    parser_compile.add_argument(
        "input",
        metavar="INPUT",
        nargs="?",
        default=None,
        help="Omnifest to compile to or none for STDIN.",
    )
    parser_compile.add_argument(
        "-o",
        "--output",
        default=None,
        help="File to output to or none for STDOUT.",
    )
    parser_compile.add_argument(
        "-t",
        "--target",
        default=None,
        help="Target to output, required if more than one target exists in an omnifest.",
    )

    parser_validate = subparsers.add_parser("validate", help="Validate an omnifest.")
    parser_validate.add_argument(
        "input",
        metavar="INPUT",
        nargs="?",
        default=None,
        help="Omnifest to validate to or none for STDIN.",
    )
    parser_validate.add_argument(
        "-t",
        "--target",
        default=None,
        help="Target to validate, required if more than one target exists in an omnifest.",
    )

    return parser
